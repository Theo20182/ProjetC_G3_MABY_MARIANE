#include "graph.h"
#define VOISIN_MAX  7
#define LOVE_MAX    10


int calculTailleTab(Graph* G, int id) {
    int taille = 0;
    while(G->list_successors[id] != NULL){
        taille++;
        G->list_successors[id] = G->list_successors[id]->successor;
    }
   return taille;     
}

void afficheVoisin(Graph* G, int id) {
     while(G->list_successors[id] != NULL){
        printf("voisin:%d\n", G->list_successors[id]->id);
        G->list_successors[id] = G->list_successors[id]->successor;
    }
}

int calculNb_arcs(const char* name_file) {
    int nb_arcs = 0;
    int u, v, w;

	FILE *fp;
	fp = fopen(name_file, "r");
  
	if (fp != NULL) // le fichier est trouve
	{
		while(fscanf(fp,"%d%d%d", &u, &v, &w) == 3) //on lit jusqu'à la fin du fichier
		{
			nb_arcs += 1;
		}
	}
	else 
        printf("Le fichier n'a pas été trouvé.");
    
	fclose(fp);
	return nb_arcs;
}

void deleteDoublons(Graph* G, int id) {
    int taille = VOISIN_MAX;
    int tab1[taille]
    int tab2[taille];
    int k=0;
    //int tab_i_doublons[];     
    while(G->list_successors[id] != NULL) {
        tab1[k] = G->list_successors[id]->id;
        tab2[k] = k;
        //printf("%d %d\n", tab[k][0], tab[k][1]);
        G->list_successors[id] = G->list_successors[id]->successor;
        k++;
    }

    
    for(int i = 0; i < taille1; i++) {
        for(int j = 0; (j < taille1) && (j !=i ); i++) {
            if(tab1[j][0] == tab[i][0]) {
                printf("coucou\n");
            }
        }
    }
}
    

void writeFile(int L) {
    int v, l;   //L'id du voisin, le degré de love
    int j;      //Le nombre de voisin   
    srand(time(NULL));
    FILE *fp;
    char name_file[20];
    
    printf("Enter file name :");
	scanf("%s", name_file);
    
    fp = fopen(name_file, "w");
    fprintf(fp, "%d\n", L);
    
    
    
    for(int i = 0; i < L; i++) {  //On itère sur l'id de l'individu
        j = rand()%VOISIN_MAX; //On choisit son nombre de voisin
        for(int k = 0; k <= j; k++){    //On itère sur l'id de voisin
            v = rand()%L;       //On choisit l'id du voisin
            if(v != i){                     //On s'assure que                                           l'individu n'est pas son                                    propre voisin                           
                l = rand()%LOVE_MAX + 1; //On choisit le degré de love
                fprintf(fp, "%d %d %d\n", i, v, l); //On écrit
            }
        }
    }
    fclose(fp);
}



void createGraph(Graph* G)
{
	FILE *fp;
    char name_file[20];
    
    printf("Enter file name :");
	scanf("%s", name_file);
	fp = fopen(name_file, "r");
    
    int id;
    printf("CHOOSE THE FIRST SICK : \n"); //Entrer l'id
	printf("(enter an id)\n");
	scanf("%d", &id);
    
	if (fp != NULL) 
	{
		int nb_nodes, nb_arcs, u, v, w;
        nb_arcs = calculNb_arcs(name_file);
        
        fscanf(fp, "%d", &nb_nodes);
		G->nb_nodes = nb_nodes;
		G->list_successors = (Node**) malloc(nb_nodes * sizeof(Node*));

		for (int i = 0; i < nb_nodes; i++) { 
			G->list_successors[i] = NULL;
        }

		for (int j = 0; j < nb_arcs; j++)
		{
			fscanf(fp, "%d %d %d", &u, &v, &w);
			Node* s	= (Node*) malloc(sizeof(Node)); 
			s->id = v;
			s->love	= w;
            
            if(id == u)
                s->state = 1;
            else
                s->state = 0;
            
            s->faiblesse = (rand()%100);
            s->force = (rand()%100);
            s->dead = 100 - s->force;
			s->successor = G->list_successors[u];
			G->list_successors[u] = s;
            printf("id : %d voisin : %d affinite : %d etat : %d\n", u, s->id, s->love, s->state);
            printf("faiblesse : %f force : %f dead : %f\n", s->faiblesse, s->force, s->dead);
		}
	}
	else printf("File not found.");
	fclose(fp);
}

void initStat(Graph* G) {
    for(int i = 0; i < G->nb_nodes; i++){
        float faiblesse = rand()%100;
        float force = rand()%100;
        float dead = 100-force;
        while (G->list_successors[i] != NULL) {
                G->list_successors[i]->faiblesse = faiblesse;
        
                G->list_successors[i]->force = force;
        
                G->list_successors[i]->dead = dead;
        
                G->list_successors[i] = G->list_successors[i]->successor;
        }     
    }
}


void maladieAttack(Graph* G, Node* s) {
    int id = s->id; 
    if (s->state == 1) {
        while (G->list_successors[id] != NULL) {
            if (s->love * s->faiblesse >= 500) {
                G->list_successors[id]->state = 1;
            }
            G->list_successors[id] = G->list_successors[id]->successor;
        } 
    }
}

void step(Graph* G){
    for (int i = 0; i < G->nb_nodes; i++) {
        while (G->list_successors[i] != NULL) {
            
        }
    }
}

//Probleme: Eviter le cas pathologique de doublons

int main(void) {
    int L = 10;
    srand(time(NULL));
    Graph G;
    
    writeFile(L);
    createGraph(&G);
 //   initStat(&G);
    deleteDoublons(&G, 5);
    return 0;
}
